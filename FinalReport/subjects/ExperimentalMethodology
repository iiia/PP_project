Test Environment: 
OS: ArchLinux 
CPU: intel i7, 4 core
Test Environment: 

Chessboard Implementation:
	Our chessboard is built with bitmap. We enum integer 1-15 as different kind of piece, and put these integers into a 64-integer-array, which represented our board. Different integer(peice) would be mapped to its own defined method that help to determine whether a move is avaliable.
	
'''''''''''''''''''''code''''''''''''''''''''''''''
enum EPieceCode
{
	epc_empty   = ept_pnil,
	epc_wpawn   = ept_wpawn,
	epc_woff    = ept_bpawn, // may be used as off the board blocker in mailbox
	epc_wknight = ept_knight,
	epc_wbishop = ept_bishop,
	epc_wrook   = ept_rook,
	epc_wqueen  = ept_queen,
	epc_wking   = ept_king,

	epc_blacky  = 8, // color code, may used as off the board blocker in mailbox
	epc_boff    = ept_wpawn  + epc_blacky, // may be used as off the board blocker in mailbox
	epc_bpawn   = ept_bpawn  + epc_blacky,
	epc_bknight = ept_knight + epc_blacky,
	epc_bbishop = ept_bishop + epc_blacky,
	epc_brook   = ept_rook   + epc_blacky,
	epc_bqueen  = ept_queen  + epc_blacky,
	epc_bking   = ept_king   + epc_blacky,
};

class ChessBoard {

	public:
		int boardMap[64]; 
		map<int,Piece*> pieceMap;
}
'''''''''''''''''''''code''''''''''''''''''''''''''

For the evaluation for the algorithm to search, we have different scoreboards for different pieces. We add up the score*weight of each piece on the board.

For detail implementation please refer to our original code.
Our code can be found on this Github repo:
https://github.com/spencerwuwu/PP_project/tree/master/src

Testing method:
 Since that we are can not guarantee to have the same result by searching the same board, which we will explain the reason for it later, and that alpha-beta may cut up in the middle of the search, we compare our data by plotting the line chart of the time of each step for different serach methods and different depths. 
So we have different graph for different search depth, each graph compares the time to search for each round by different search algorithm.

To test the scalability of our algorithm, we compare the performance of different number of thread created in depth 5 and depth 6.
